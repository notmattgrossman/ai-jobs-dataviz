// Combined Tech Job Vulnerability transition (bubble -> scatter)
let techJobVulnerabilityTransition = null;
let techJobVulnerabilityTransitionData = null;
const techTransitionTheme = window.aiVizTheme || {};
const techTransitionTextPrimary = techTransitionTheme.palette?.textPrimary || "#f6f7ff";
const techTransitionTextMuted = techTransitionTheme.palette?.textMuted || "#9da7c2";
const techTransitionGridColor = techTransitionTheme.gridline || "rgba(255,255,255,0.12)";

function createTechJobVulnerabilityTransition() {
    const container = d3.select("#tech-job-vulnerability-transition");
    if (container.empty()) {
        console.warn("tech-job-vulnerability-transition container not found");
        return null;
    }

    container.selectAll("*").remove();

    if (!techJobVulnerabilityTransition) {
        techJobVulnerabilityTransition = {
            progress: 0,
            ready: false,
            setProgress(value) {
                this.progress = clamp01(value);
            },
        };
    }

    const state = techJobVulnerabilityTransition;
    state.ready = false;

    const dataPromise = techJobVulnerabilityTransitionData
        ? Promise.resolve(techJobVulnerabilityTransitionData)
        : d3.csv("data/Data/fig_4.2.25.csv");

    dataPromise.then((rawData) => {
        rawData.forEach((d) => {
            d.riskScore = parseFloat(d.pct_occ_scaled);
            d.salary = parseFloat(d.MedianSalary);
        });

        if (!techJobVulnerabilityTransitionData) {
            techJobVulnerabilityTransitionData = rawData;
        }

        const cleaned = rawData.filter(
            (d) => !isNaN(d.riskScore) && !isNaN(d.salary)
        );
        const top50 = cleaned
            .slice()
            .sort((a, b) => b.riskScore - a.riskScore)
            .slice(0, 50);

        const margin = { top: 90, right: 60, bottom: 110, left: 80 };
        const viewWidth = 960;
        const viewHeight = 700;
        const width = viewWidth - margin.left - margin.right;
        const height = viewHeight - margin.top - margin.bottom;

        const svg = container
            .append("svg")
            .attr("width", "100%")
            .attr("height", viewHeight)
            .attr("viewBox", `0 0 ${viewWidth} ${viewHeight}`)
            .attr("preserveAspectRatio", "xMidYMid meet");

        const g = svg
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        const xScale = d3
            .scaleLinear()
            .domain(d3.extent(top50, (d) => d.riskScore))
            .nice()
            .range([0, width]);

        const yScale = d3
            .scaleLinear()
            .domain(d3.extent(top50, (d) => d.salary))
            .nice()
            .range([height, 0]);

        const radiusScale = d3
            .scaleSqrt()
            .domain(d3.extent(top50, (d) => d.riskScore))
            .range([6, 85]);

        const colorInterpolator = d3
            .scaleLinear()
            .domain(d3.extent(top50, (d) => d.riskScore))
            .range([
                techTransitionTheme.palette?.divergingPositive ||
                    techTransitionTheme.palette?.accentSecondary ||
                    "#43cbff",
                techTransitionTheme.palette?.divergingNegative ||
                    techTransitionTheme.palette?.negative ||
                    "#ff5c8d"
            ])
            .interpolate(d3.interpolateRgb);

        top50.forEach((d, i) => {
            d.scatterX = xScale(d.riskScore);
            d.scatterY = yScale(d.salary);
            d.bubbleRadius = radiusScale(d.riskScore);
            d.isTop5 = i < 5;
            d.title = d.Title;
        });

        const scatterAxisGroup = svg
            .append("g")
            .attr("class", "scatter-axes")
            .attr("transform", `translate(${margin.left},${margin.top})`)
            .style("opacity", 0);

        scatterAxisGroup
            .append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(xScale).ticks(8))
            .selectAll("text")
            .attr("font-size", "11px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("fill", techTransitionTextMuted);

        scatterAxisGroup
            .select(".x-axis")
            .selectAll("line, path")
            .attr("stroke", techTransitionGridColor);

        scatterAxisGroup
            .append("text")
            .attr("class", "axis-label")
            .attr("x", width / 2)
            .attr("y", height + 40)
            .attr("text-anchor", "middle")
            .attr("font-size", "12px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("fill", techTransitionTextPrimary)
            .text("Risk Score");

        scatterAxisGroup
            .append("g")
            .attr("class", "y-axis")
            .call(
                d3
                    .axisLeft(yScale)
                    .ticks(8)
                    .tickFormat((d) => `$${(d / 1000).toFixed(0)}K`)
            )
            .selectAll("text")
            .attr("font-size", "11px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("fill", techTransitionTextMuted);

        scatterAxisGroup
            .select(".y-axis")
            .selectAll("line, path")
            .attr("stroke", techTransitionGridColor);

        scatterAxisGroup
            .append("text")
            .attr("class", "axis-label")
            .attr("transform", "rotate(-90)")
            .attr("x", -height / 2)
            .attr("y", -60)
            .attr("text-anchor", "middle")
            .attr("font-size", "12px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("fill", techTransitionTextPrimary)
            .text("Median Salary");

        const bubbleTitleGroup = svg
            .append("g")
            .attr("class", "bubble-title")
            .style("opacity", 1);

        bubbleTitleGroup
            .append("text")
            .attr("x", viewWidth / 2)
            .attr("y", 30)
            .attr("text-anchor", "middle")
            .attr("font-size", "16px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("font-weight", "300")
            .attr("fill", techTransitionTextPrimary)
            .text("Job Vulnerability by Risk Score");

        bubbleTitleGroup
            .append("text")
            .attr("x", viewWidth / 2)
            .attr("y", 52)
            .attr("text-anchor", "middle")
            .attr("font-size", "12px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("fill", techTransitionTextMuted)
            .text("Larger circles indicate higher AI replacement risk.");

        const scatterTitleGroup = svg
            .append("g")
            .attr("class", "scatter-title")
            .style("opacity", 0);

        scatterTitleGroup
            .append("text")
            .attr("x", viewWidth / 2)
            .attr("y", 30)
            .attr("text-anchor", "middle")
            .attr("font-size", "16px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("font-weight", "300")
            .attr("fill", techTransitionTextPrimary)
            .text("Job Vulnerability vs. Salary");

        const circles = g
            .selectAll("circle.job-node")
            .data(top50, (d) => d.title)
            .enter()
            .append("circle")
            .attr("class", "job-node")
            .attr("r", (d) => d.bubbleRadius)
            .attr("fill", (d) => colorInterpolator(d.riskScore))
            .attr("stroke", "rgba(5,6,13,0.45)")
            .attr("stroke-width", 1.2)
            .attr("opacity", 0.85);

        const labels = g
            .selectAll("text.job-label")
            .data(top50, (d) => d.title)
            .enter()
            .append("text")
            .attr("class", "job-label")
            .attr("text-anchor", "middle")
            .attr("font-size", "12px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("font-weight", "300")
            .attr("fill", techTransitionTextPrimary)
            .style("pointer-events", "none")
            .style("opacity", (d) => (d.isTop5 ? 1 : 0))
            .text((d) => (d.isTop5 ? d.title : ""));

        d3.forceSimulation(top50)
            .force("x", d3.forceX(width / 2).strength(0.07))
            .force("y", d3.forceY(height / 2).strength(0.07))
            .force(
                "collide",
                d3.forceCollide().radius((d) => d.bubbleRadius + 3)
            )
            .force("charge", d3.forceManyBody().strength(-80))
            .on("tick", () => {
                circles.attr("cx", (d) => d.x).attr("cy", (d) => d.y);
                labels.attr("x", (d) => d.x).attr("y", (d) => d.y);
            })
            .on("end", () => {
                top50.forEach((d) => {
                    d.bubbleX = d.x;
                    d.bubbleY = d.y;
                });
                state.ready = true;
                state.setProgress(state.progress);
            });

        const scatterRadius = 6;
        const morphStart = 0.4;
        const morphEnd = 0.7;

        state.setProgress = function setProgress(value) {
            const clamped = clamp01(value);
            this.progress = clamped;
            if (!this.ready) {
                return;
            }

            const morphT = clamp01(
                (clamped - morphStart) / (morphEnd - morphStart)
            );
            const scatterPhase = clamp01((clamped - 0.7) / 0.3);

            circles
                .attr("cx", (d) => lerp(d.bubbleX, d.scatterX, morphT))
                .attr("cy", (d) => lerp(d.bubbleY, d.scatterY, morphT))
                .attr("r", (d) => lerp(d.bubbleRadius, scatterRadius, morphT))
                .attr("opacity", 0.7 + 0.3 * scatterPhase);

            labels.style("opacity", (d) =>
                d.isTop5 ? 1 - morphT : 0
            );

            scatterAxisGroup.style("opacity", morphT);
            bubbleTitleGroup.style("opacity", Math.max(0, 1 - morphT * 1.2));
            scatterTitleGroup.style("opacity", Math.min(1, morphT * 1.2));
        };
    });

    return state;
}

function setTechJobVulnerabilityProgress(progressValue) {
    if (!techJobVulnerabilityTransition) {
        createTechJobVulnerabilityTransition();
    }

    if (techJobVulnerabilityTransition) {
        techJobVulnerabilityTransition.setProgress(progressValue);
    }
}

function lerp(a, b, t) {
    return a + (b - a) * t;
}

function clamp01(value) {
    if (value < 0) return 0;
    if (value > 1) return 1;
    return value;
}
