// Tech Job Vulnerability Visualization - Unified Scroll-Driven Version
// Single visualization that morphs from bubble chart to scatter plot

const techScrollTheme = window.aiVizTheme || {};
const techScrollTextPrimary = techScrollTheme.palette?.textPrimary || "#f6f7ff";
const techScrollTextMuted = techScrollTheme.palette?.textMuted || "#9da7c2";
const techScrollGridColor = techScrollTheme.gridline || "rgba(255,255,255,0.12)";
let techJobVulnerabilityViz = null;
let techJobVulnerabilityData = null;

function createTechJobVulnerability() {
    // Clear existing visualization
    d3.select("#tech-job-vulnerability").selectAll("*").remove();

    const dataPromise = techJobVulnerabilityData ? Promise.resolve(techJobVulnerabilityData) : d3.csv("data/Data/fig_4.2.25.csv");
    
    dataPromise.then(function(data) {
        // Parse data
        data.forEach(function(d) {
            d.riskScore = parseFloat(d.pct_occ_scaled);
            d.salary = parseFloat(d.MedianSalary);
        });

        // Cache data
        if (!techJobVulnerabilityData) {
            techJobVulnerabilityData = data;
        }

        // Filter out any invalid data points
        const validData = data.filter(d => !isNaN(d.riskScore) && !isNaN(d.salary));

        // Sort by risk score (descending) and take top 50 for bubble chart
        const top50 = validData.sort((a, b) => b.riskScore - a.riskScore).slice(0, 50);

        // Set up dimensions - use scatter plot dimensions for unified view
        const margin = { top: 130, right: 60, bottom: 120, left: 100 };
        const baseWidth = 900;
        const width = baseWidth - margin.left - margin.right;
        const height = 700 - margin.top - margin.bottom;
        const svgWidth = baseWidth;
        const svgHeight = height + margin.top + margin.bottom;

        // Create SVG
        const svg = d3.select("#tech-job-vulnerability")
            .append("svg")
            .attr("width", "100%")
            .attr("height", svgHeight)
            .attr("viewBox", `0 0 ${svgWidth} ${svgHeight}`)
            .attr("preserveAspectRatio", "xMidYMid meet")
            .style("border", "none")
            .style("outline", "none")
            .style("background", "transparent")
            .style("background-color", "transparent")
            .style("background-image", "none")
            .style("box-shadow", "none")
            .attr("style", "border: none !important; outline: none !important; background: transparent !important; background-color: transparent !important; box-shadow: none !important;");
        
        // Also ensure the container div and parent containers have no border/background
        d3.select("#tech-job-vulnerability")
            .style("border", "none")
            .style("outline", "none")
            .style("background", "transparent")
            .style("background-color", "transparent")
            .style("box-shadow", "none");
        
        d3.select("#tech-job-vulnerability-container")
            .style("border", "none")
            .style("outline", "none")
            .style("background", "transparent")
            .style("background-color", "transparent")
            .style("box-shadow", "none");

        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);

        // Create tooltip
        const tooltip = d3.select("body")
            .append("div")
            .attr("class", "tooltip")
            .style("opacity", 0)
            .style("position", "fixed")
            .style("padding", "6px 10px")
            .style("border-radius", "8px")
            .style("font-size", "11px")
            .style("font-family", "'Stack Sans Notch', serif")
            .style("pointer-events", "none")
            .style("z-index", "1000");

        if (techScrollTheme.styleTooltip) {
            techScrollTheme.styleTooltip(tooltip);
        }

        // ============================================================================
        // SCATTER PLOT SCALES (pre-calculate for transition targets)
        // ============================================================================
        const xScale = d3.scaleLinear()
            .domain(d3.extent(validData, d => d.riskScore))
            .range([0, width])
            .nice();

        const yScale = d3.scaleLinear()
            .domain(d3.extent(validData, d => d.salary))
            .range([height, 0])
            .nice();

        // ============================================================================
        // BUBBLE CHART SETUP
        // ============================================================================
        // Helper function to calculate text width
        const getTextWidth = (text, fontSize) => {
            const tempSvg = d3.select("body")
                .append("svg")
                .style("position", "absolute")
                .style("visibility", "hidden")
                .style("width", 0)
                .style("height", 0);
            const temp = tempSvg.append("text")
                .attr("font-size", fontSize + "px")
                .attr("font-weight", "300")
                .text(text);
            const width = temp.node().getBBox().width;
            tempSvg.remove();
            return width;
        };

        // Helper function to calculate optimal font size to fit in circle
        const calculateOptimalFontSize = (text, radius) => {
            const maxWidth = radius * 1.8;
            let fontSize = Math.max(8, Math.min(14, radius / 3));
            let textWidth = getTextWidth(text, fontSize);
            
            while (textWidth > maxWidth && fontSize > 6) {
                fontSize -= 0.5;
                textWidth = getTextWidth(text, fontSize);
            }
            
            return { fontSize, fits: textWidth <= maxWidth };
        };

        // Scale for circle radius based on risk score
        // Ensure max radius fits within bounds (accounting for margins)
        const maxRisk = d3.max(top50, d => d.riskScore);
        const minRisk = d3.min(top50, d => d.riskScore);
        const maxRadius = Math.min(90, Math.min(width, height) * 0.15); // Ensure circles fit within bounds
        const radiusScale = d3.scaleSqrt()
            .domain([minRisk, maxRisk])
            .range([5, maxRadius]);

        // Pre-calculate font sizes and fit status
        top50.forEach(function(d) {
            const radius = radiusScale(d.riskScore);
            const textInfo = calculateOptimalFontSize(d.Title, radius);
            d.fontSize = textInfo.fontSize;
            d.textFits = textInfo.fits;
        });

        // Mark the top 5 largest circles
        top50.forEach(function(d, i) {
            d.isTop5 = i < 5;
        });

        const colorInterpolator = d3.scaleLinear()
            .domain([minRisk, maxRisk])
            .range([
                techScrollTheme.palette?.divergingPositive || techScrollTheme.palette?.accentSecondary || "#43cbff",
                techScrollTheme.palette?.divergingNegative || techScrollTheme.palette?.negative || "#ff5c8d"
            ])
            .interpolate(d3.interpolateRgb);

        // Initialize positions around center - larger circles start closer to center
        top50.forEach(function(d) {
            const radius = radiusScale(d.riskScore);
            const maxRadius = radiusScale(maxRisk);
            // Larger circles start closer to center (based on relative size)
            const distanceFromCenter = (1 - radius / maxRadius) * Math.min(width, height) * 0.25;
            const angle = Math.random() * Math.PI * 2;
            d.x = width / 2 + Math.cos(angle) * distanceFromCenter;
            d.y = height / 2 + Math.sin(angle) * distanceFromCenter;
        });

        // Create a force simulation to position circles around center without overlaps
        // Larger circles are pulled more strongly towards center
        const simulation = d3.forceSimulation(top50)
            .force("x", d3.forceX(width / 2).strength(d => {
                const radius = radiusScale(d.riskScore);
                const maxRadius = radiusScale(maxRisk);
                // Larger circles get stronger pull (0.4 for largest, 0.15 for smallest)
                return 0.15 + (radius / maxRadius) * 0.25;
            }))
            .force("y", d3.forceY(height / 2).strength(d => {
                const radius = radiusScale(d.riskScore);
                const maxRadius = radiusScale(maxRisk);
                // Larger circles get stronger pull (0.4 for largest, 0.15 for smallest)
                return 0.15 + (radius / maxRadius) * 0.25;
            }))
            .force("collision", d3.forceCollide().radius(d => radiusScale(d.riskScore) + 5).strength(1))
            .force("charge", d3.forceManyBody().strength(-200))
            .alphaDecay(0.01) // Slower decay for smoother settling
            .alphaMin(0.01) // Keep running until fully settled
            .velocityDecay(0.6); // More friction for stability

        // Create circles (these will morph into scatter points)
        const circles = g.selectAll("circle")
            .data(top50)
            .enter()
            .append("circle")
            .attr("r", d => radiusScale(d.riskScore))
            .attr("fill", d => colorInterpolator(d.riskScore))
            .attr("stroke", "rgba(5,6,13,0.45)")
            .attr("stroke-width", 1)
            .attr("opacity", 0.9)
            .on("mouseover", function(event, d) {
                tooltip.transition()
                    .duration(200)
                    .style("opacity", 1);
                tooltip.html(`${d.Title}<br/>Risk Score: ${d.riskScore.toFixed(2)}<br/>Salary: $${d.salary.toLocaleString()}`);
                
                d3.select(this)
                    .attr("stroke-width", 2)
                    .attr("stroke", techScrollTextPrimary);
            })
            .on("mousemove", function(event) {
                tooltip
                    .style("left", (event.clientX) + "px")
                    .style("top", (event.clientY - 80) + "px")
                    .style("transform", "translateX(-50%)");
            })
            .on("mouseout", function() {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
                
                d3.select(this)
                    .attr("stroke-width", 1)
                    .attr("stroke", "rgba(5,6,13,0.45)");
            });

        // Add labels - only show on the top 5 largest circles
        const labels = g.selectAll("text.label")
            .data(top50)
            .enter()
            .append("text")
            .attr("class", "label")
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "middle")
            .attr("font-size", d => d.fontSize + "px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("fill", techScrollTextPrimary)
            .attr("font-weight", "300")
            .text(d => d.Title)
            .style("pointer-events", "none")
            .style("opacity", d => d.isTop5 ? 1 : 0);

        // Update positions on simulation tick and store initial positions
        let positionsStored = false;
        simulation.on("tick", function() {
            // Boundary constraints are already applied in the simulation's tick handler
            circles
                .attr("cx", d => {
                    if (d.x === undefined) d.x = width / 2;
                    const r = radiusScale(d.riskScore);
                    // Ensure circles stay within bounds
                    const constrainedX = Math.max(r, Math.min(width - r, d.x));
                    d.x = constrainedX;
                    return constrainedX;
                })
                .attr("cy", d => {
                    if (d.y === undefined) d.y = height / 2;
                    const r = radiusScale(d.riskScore);
                    // Ensure circles stay within bounds
                    const constrainedY = Math.max(r, Math.min(height - r, d.y));
                    d.y = constrainedY;
                    return constrainedY;
                });

            labels
                .attr("x", d => {
                    const r = radiusScale(d.riskScore);
                    return Math.max(r, Math.min(width - r, d.x || width / 2));
                })
                .attr("y", d => {
                    const r = radiusScale(d.riskScore);
                    return Math.max(r, Math.min(height - r, d.y || height / 2));
                });
        });

        // After simulation settles, store initial positions and calculate target positions
        simulation.on("end", function() {
            if (!positionsStored) {
                top50.forEach(function(d) {
                    // Store initial bubble positions
                    d.bubbleX = d.x || width / 2;
                    d.bubbleY = d.y || height / 2;
                    d.bubbleRadius = radiusScale(d.riskScore);
                    
                    // Calculate target scatter plot positions
                    d.scatterX = xScale(d.riskScore);
                    d.scatterY = yScale(d.salary);
                    d.scatterRadius = 4;
                });
                positionsStored = true;
                // Stop the simulation to prevent interference with transitions
                simulation.stop();
            }
        });

        // Also store positions after a delay to ensure simulation has run and settled
        setTimeout(function() {
            if (!positionsStored) {
                top50.forEach(function(d) {
                    d.bubbleX = d.x || width / 2;
                    d.bubbleY = d.y || height / 2;
                    d.bubbleRadius = radiusScale(d.riskScore);
                    d.scatterX = xScale(d.riskScore);
                    d.scatterY = yScale(d.salary);
                    d.scatterRadius = 4;
                });
                positionsStored = true;
                simulation.stop();
            }
        }, 3000); // Increased delay to allow simulation to fully settle

        // ============================================================================
        // SCATTER PLOT AXES (created but hidden initially)
        // ============================================================================
        // Add grid lines first (hidden initially)
        const gridX = g.append("g")
            .attr("class", "grid-x")
            .attr("transform", `translate(0,${height})`)
            .call(d3.axisBottom(xScale)
                .ticks(8)
                .tickSize(-height)
                .tickFormat(""))
            .selectAll("line")
            .attr("stroke", techScrollGridColor)
            .attr("stroke-width", 1)
            .style("opacity", 0);

        const gridY = g.append("g")
            .attr("class", "grid-y")
            .call(d3.axisLeft(yScale)
                .ticks(8)
                .tickSize(-width)
                .tickFormat(""))
            .selectAll("line")
            .attr("stroke", techScrollGridColor)
            .attr("stroke-width", 1)
            .style("opacity", 0);

        // Add x-axis (hidden initially)
        const xAxis = d3.axisBottom(xScale)
            .ticks(8);

        const xAxisGroup = g.append("g")
            .attr("class", "x-axis")
            .attr("transform", `translate(0,${height})`)
            .call(xAxis)
            .style("opacity", 0);

        xAxisGroup.selectAll("text")
            .attr("font-size", "11px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("font-weight", "300")
            .attr("fill", techScrollTextMuted);

        // Add x-axis label (hidden initially)
        const xAxisLabel = svg.append("text")
            .attr("class", "axis-label-x")
            .attr("x", width / 2 + margin.left)
            .attr("y", margin.top + height + 40)
            .attr("text-anchor", "middle")
            .attr("font-size", "12px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("fill", techScrollTextPrimary)
            .style("opacity", 0);
        
        xAxisLabel.append("tspan")
            .attr("font-weight", "300")
            .text("Risk Score");
        
        xAxisLabel.append("tspan")
            .attr("font-weight", "300")
            .attr("font-style", "italic")
            .attr("fill", techScrollTextMuted)
            .text(" (Higher risk score means more vulnerable)");

        // Add y-axis (hidden initially)
        const yAxis = d3.axisLeft(yScale)
            .ticks(8)
            .tickFormat(d => "$" + (d / 1000) + "K");

        const yAxisGroup = g.append("g")
            .attr("class", "y-axis")
            .call(yAxis)
            .style("opacity", 0);

        yAxisGroup.selectAll("text")
            .attr("font-size", "11px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("font-weight", "300")
            .attr("fill", techScrollTextMuted);

        yAxisGroup.select(".domain")
            .attr("stroke", "none");

        const yAxisLabel = g.append("text")
            .attr("class", "axis-label-y")
            .attr("transform", "rotate(-90)")
            .attr("y", -60)
            .attr("x", -height / 2)
            .attr("text-anchor", "middle")
            .attr("font-size", "12px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("font-weight", "300")
            .attr("fill", techScrollTextPrimary)
            .text("Median Salary")
            .style("opacity", 0);

        // Add title (will change during transition)
        const title = svg.append("text")
            .attr("x", width / 2 + margin.left)
            .attr("y", 85)
            .attr("text-anchor", "middle")
            .attr("font-size", "16px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("font-weight", "300")
            .attr("fill", techScrollTextPrimary)
            .text("Job Vulnerability Risk Scores");

        // Add subtitle (will be hidden during transition)
        const subtitle = svg.append("text")
            .attr("x", width / 2 + margin.left)
            .attr("y", 105)
            .attr("text-anchor", "middle")
            .attr("font-size", "12px")
            .attr("font-family", "'Stack Sans Notch', serif")
            .attr("font-weight", "300")
            .attr("fill", techScrollTextMuted)
            .text("Larger circles show a higher risk score for AI job vulnerability");

        // Store visualization references
        techJobVulnerabilityViz = { 
            svg, 
            g, 
            simulation, 
            circles, 
            labels,
            top50,
            xScale,
            yScale,
            radiusScale,
            colorInterpolator,
            gridX,
            gridY,
            xAxisGroup,
            yAxisGroup,
            xAxisLabel,
            yAxisLabel,
            title,
            subtitle,
            width,
            height
        };
    }).catch(function(error) {
        console.error("Error loading CSV:", error);
    });
}

// ============================================================================
// TRANSITION FUNCTION
// ============================================================================
function updateTechVulnerabilityTransition(scrollPercent) {
    if (!techJobVulnerabilityViz || !techJobVulnerabilityViz.top50) {
        return;
    }

    const viz = techJobVulnerabilityViz;
    const { circles, labels, top50, xAxisGroup, yAxisGroup, xAxisLabel, yAxisLabel, gridX, gridY, title, subtitle, simulation, xScale, yScale, radiusScale, width, height } = viz;

    // Stop simulation if it's still running (to prevent interference)
    if (simulation && simulation.alpha() > 0) {
        simulation.stop();
    }

    if (scrollPercent < 40) {
        // 0-40%: No changes (bubble chart fully visible)
        // Ensure circles are at bubble positions
        circles.each(function(d) {
            // Use stored bubble positions if available, otherwise use current positions
            let x = d.bubbleX !== undefined ? d.bubbleX : (d.x || width / 2);
            let y = d.bubbleY !== undefined ? d.bubbleY : (d.y || height / 2);
            const r = d.bubbleRadius !== undefined ? d.bubbleRadius : radiusScale(d.riskScore);
            
            // Constrain to bounds
            x = Math.max(r, Math.min(width - r, x));
            y = Math.max(r, Math.min(height - r, y));
            
            d3.select(this)
                .attr("cx", x)
                .attr("cy", y)
                .attr("r", r);
        });
        
        // Labels visible
        labels.style("opacity", d => d.isTop5 ? 1 : 0);
        
        // Axes hidden
        xAxisGroup.style("opacity", 0);
        yAxisGroup.style("opacity", 0);
        xAxisLabel.style("opacity", 0);
        yAxisLabel.style("opacity", 0);
        gridX.style("opacity", 0);
        gridY.style("opacity", 0);
        
        // Title and subtitle visible
        title.text("Job Vulnerability Risk Scores").style("opacity", 1);
        subtitle.style("opacity", 1);
        
    } else if (scrollPercent >= 40 && scrollPercent < 60) {
        // 40-60%: Morph bubbles to scatter positions
        const t = (scrollPercent - 40) / 20; // Interpolation factor: 0 to 1
        
        circles.each(function(d) {
            // Use stored positions if available, otherwise calculate on the fly
            let bubbleX = d.bubbleX !== undefined ? d.bubbleX : (d.x || width / 2);
            let bubbleY = d.bubbleY !== undefined ? d.bubbleY : (d.y || height / 2);
            const bubbleR = d.bubbleRadius !== undefined ? d.bubbleRadius : radiusScale(d.riskScore);
            const scatterX = d.scatterX !== undefined ? d.scatterX : xScale(d.riskScore);
            const scatterY = d.scatterY !== undefined ? d.scatterY : yScale(d.salary);
            const scatterR = d.scatterRadius !== undefined ? d.scatterRadius : 4;
            
            // Constrain bubble positions to bounds
            bubbleX = Math.max(bubbleR, Math.min(width - bubbleR, bubbleX));
            bubbleY = Math.max(bubbleR, Math.min(height - bubbleR, bubbleY));
            
            // Interpolate position
            let cx = bubbleX + (scatterX - bubbleX) * t;
            let cy = bubbleY + (scatterY - bubbleY) * t;
            // Interpolate radius
            const r = bubbleR + (scatterR - bubbleR) * t;
            
            // Constrain interpolated positions to bounds
            cx = Math.max(r, Math.min(width - r, cx));
            cy = Math.max(r, Math.min(height - r, cy));
            
            d3.select(this)
                .attr("cx", cx)
                .attr("cy", cy)
                .attr("r", r);
        });
        
        // Fade out labels
        const labelOpacity = 1 - t;
        labels.style("opacity", d => {
            const baseOpacity = d.isTop5 ? 1 : 0;
            return baseOpacity * labelOpacity;
        });
        
        // Update label positions
        labels.each(function(d) {
            const bubbleX = d.bubbleX !== undefined ? d.bubbleX : (d.x || width / 2);
            const bubbleY = d.bubbleY !== undefined ? d.bubbleY : (d.y || height / 2);
            const scatterX = d.scatterX !== undefined ? d.scatterX : xScale(d.riskScore);
            const scatterY = d.scatterY !== undefined ? d.scatterY : yScale(d.salary);
            
            const x = bubbleX + (scatterX - bubbleX) * t;
            const y = bubbleY + (scatterY - bubbleY) * t;
            d3.select(this)
                .attr("x", x)
                .attr("y", y);
        });
        
        // Fade in axes from 55% to 60% (5% range)
        let axesOpacity = 0;
        if (scrollPercent >= 55) {
            axesOpacity = Math.min(1, (scrollPercent - 55) / 5); // Fade in over 5%
        }
        xAxisGroup.style("opacity", axesOpacity);
        yAxisGroup.style("opacity", axesOpacity);
        xAxisLabel.style("opacity", axesOpacity);
        yAxisLabel.style("opacity", axesOpacity);
        gridX.style("opacity", axesOpacity);
        gridY.style("opacity", axesOpacity);
        
        // Update title
        title.text("Job Vulnerability Risk Scores").style("opacity", 1);
        subtitle.style("opacity", 1 - t);
        
    } else {
        // 60-100%: Scatter plot fully visible
        // Ensure circles are at scatter positions
        circles.each(function(d) {
            const scatterX = d.scatterX !== undefined ? d.scatterX : xScale(d.riskScore);
            const scatterY = d.scatterY !== undefined ? d.scatterY : yScale(d.salary);
            const scatterR = d.scatterRadius !== undefined ? d.scatterRadius : 4;
            
            d3.select(this)
                .attr("cx", scatterX)
                .attr("cy", scatterY)
                .attr("r", scatterR);
        });
        
        // Labels hidden
        labels.style("opacity", 0);
        
        // Axes fully visible (already faded in by 60%)
        xAxisGroup.style("opacity", 1);
        yAxisGroup.style("opacity", 1);
        xAxisLabel.style("opacity", 1);
        yAxisLabel.style("opacity", 1);
        gridX.style("opacity", 1);
        gridY.style("opacity", 1);
        
        // Update title - keep main title visible
        title.text("Job Vulnerability Risk Scores").style("opacity", 1);
        subtitle.style("opacity", 0);
    }
}

// ============================================================================
// INITIALIZATION
// ============================================================================
// Initialize on load
$(document).ready(function() {
    setTimeout(function() {
        createTechJobVulnerability();
    }, 500);
});
