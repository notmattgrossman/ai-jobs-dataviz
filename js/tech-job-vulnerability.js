// Tech Job Vulnerability Visualization
d3.csv("data/4. Economy/Data/fig_4.2.25.csv").then(function(data) {
    const theme = window.aiVizTheme || {};
    const textPrimary = theme.palette?.textPrimary || "#f6f7ff";
    const textMuted = theme.palette?.textMuted || "#9da7c2";
    // Parse data
    data.forEach(function(d) {
        d.riskScore = parseFloat(d.pct_occ_scaled);
        d.salary = parseFloat(d.MedianSalary);
    });

    // Sort by risk score (descending) and take top 50
    const top50 = data.sort((a, b) => b.riskScore - a.riskScore).slice(0, 50);

    // Set up dimensions
    const margin = { top: 100, right: 40, bottom: 80, left: 40 };
    const baseWidth = 900;
    const width = baseWidth - margin.left - margin.right;
    const height = 700 - margin.top - margin.bottom;
    const svgWidth = baseWidth;
    const svgHeight = height + margin.top + margin.bottom;

    // Create SVG
    const svg = d3.select("#tech-job-vulnerability")
        .append("svg")
        .attr("width", "100%")
        .attr("height", svgHeight)
        .attr("viewBox", `0 0 ${svgWidth} ${svgHeight}`)
        .attr("preserveAspectRatio", "xMidYMid meet");

    const g = svg.append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);

    // Create tooltip
    const tooltip = d3.select("body")
        .append("div")
        .attr("class", "tooltip")
        .style("opacity", 0)
        .style("position", "fixed")
        .style("padding", "6px 10px")
        .style("border-radius", "8px")
        .style("font-size", "11px")
        .style("font-family", "'Stack Sans Notch', serif")
        .style("pointer-events", "none")
        .style("z-index", "1000");

    if (theme.styleTooltip) {
        theme.styleTooltip(tooltip);
    }

    // Helper function to calculate text width
    const getTextWidth = (text, fontSize) => {
        // Create a temporary SVG for measurement
        const tempSvg = d3.select("body")
            .append("svg")
            .style("position", "absolute")
            .style("visibility", "hidden")
            .style("width", 0)
            .style("height", 0);
        const temp = tempSvg.append("text")
            .attr("font-size", fontSize + "px")
            .attr("font-weight", "300")
            .text(text);
        const width = temp.node().getBBox().width;
        tempSvg.remove();
        return width;
    };

    // Helper function to calculate optimal font size to fit in circle
    const calculateOptimalFontSize = (text, radius) => {
        const maxWidth = radius * 1.8; // Allow text to use ~90% of diameter
        let fontSize = Math.max(8, Math.min(14, radius / 3));
        let textWidth = getTextWidth(text, fontSize);
        
        // Reduce font size if text is too wide
        while (textWidth > maxWidth && fontSize > 6) {
            fontSize -= 0.5;
            textWidth = getTextWidth(text, fontSize);
        }
        
        return { fontSize, fits: textWidth <= maxWidth };
    };

    // Scale for circle radius based on risk score
    const maxRisk = d3.max(top50, d => d.riskScore);
    const minRisk = d3.min(top50, d => d.riskScore);
    const radiusScale = d3.scaleSqrt()
        .domain([minRisk, maxRisk])
        .range([5, 90]); // Minimum and maximum circle sizes - more dramatic scale

    // Create a force simulation to position circles
    const simulation = d3.forceSimulation(top50)
        .force("x", d3.forceX(width / 2).strength(0.05))
        .force("y", d3.forceY(height / 2).strength(0.05))
        .force("collision", d3.forceCollide().radius(d => radiusScale(d.riskScore) + 2))
        .force("charge", d3.forceManyBody().strength(-50));

    // Pre-calculate font sizes and fit status
    top50.forEach(function(d) {
        const radius = radiusScale(d.riskScore);
        const textInfo = calculateOptimalFontSize(d.Title, radius);
        d.fontSize = textInfo.fontSize;
        d.textFits = textInfo.fits;
    });

    // Mark the top 5 largest circles (already sorted by risk score, so first 5)
    top50.forEach(function(d, i) {
        d.isTop5 = i < 5;
    });

    const riskColorScale = d3.scaleLinear()
        .domain([minRisk, maxRisk])
        .range([
            theme.palette?.divergingPositive || theme.palette?.accentSecondary || "#43cbff",
            theme.palette?.divergingNegative || theme.palette?.negative || "#ff5c8d"
        ])
        .interpolate(d3.interpolateRgb);
    
    // Create circles
    const circles = g.selectAll("circle")
        .data(top50)
        .enter()
        .append("circle")
        .attr("r", d => radiusScale(d.riskScore))
        .attr("fill", d => riskColorScale(d.riskScore))
        .attr("stroke", "rgba(5,6,13,0.45)")
        .attr("stroke-width", 1)
        .attr("opacity", 0.9)
        .on("mouseover", function(event, d) {
            if (!d.isTop5) {
                tooltip.transition()
                    .duration(200)
                    .style("opacity", 1);
                tooltip.html(d.Title);
            }
        })
        .on("mousemove", function(event, d) {
            if (!d.isTop5) {
                tooltip
                    .style("left", (event.clientX) + "px")
                    .style("top", (event.clientY - 80) + "px")
                    .style("transform", "translateX(-50%)");
            }
        })
        .on("mouseout", function(event, d) {
            if (!d.isTop5) {
                tooltip.transition()
                    .duration(500)
                    .style("opacity", 0);
            }
        });

    // Add labels - only show on the top 5 largest circles
    const labels = g.selectAll("text")
        .data(top50)
        .enter()
        .append("text")
        .attr("text-anchor", "middle")
        .attr("alignment-baseline", "middle")
        .attr("font-size", d => d.fontSize + "px")
        .attr("font-family", "'Stack Sans Notch', serif")
        .attr("fill", textPrimary)
        .attr("font-weight", "300")
        .text(d => d.Title)
        .style("pointer-events", "none")
        .style("opacity", d => d.isTop5 ? 1 : 0); // Only show top 5

    // Update positions on simulation tick
    simulation.on("tick", function() {
        circles
            .attr("cx", d => d.x)
            .attr("cy", d => d.y);

        labels
            .attr("x", d => d.x)
            .attr("y", d => d.y);
    });

    // Add title
    svg.append("text")
        .attr("x", width / 2 + margin.left)
        .attr("y", 25)
        .attr("text-anchor", "middle")
        .attr("font-size", "16px")
        .attr("font-family", "'Stack Sans Notch', serif")
        .attr("font-weight", "300")
        .attr("fill", textPrimary)
        .text("Job Vulnerability by risk score");

    // Add subtitle
    svg.append("text")
        .attr("x", width / 2 + margin.left)
        .attr("y", 45)
        .attr("text-anchor", "middle")
        .attr("font-size", "12px")
        .attr("font-family", "'Stack Sans Notch', serif")
        .attr("font-weight", "300")
        .attr("fill", textMuted)
        .text("Larger circles show a higher risk score for AI job vulnerability");

}).catch(function(error) {
    console.error("Error loading CSV:", error);
});

